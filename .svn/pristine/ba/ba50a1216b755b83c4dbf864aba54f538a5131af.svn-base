#include <SDL.h>
#include <SDL_gfxPrimitives.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <SDL_image.h>
#include <SDL_ttf.h>
#include "game.h"
#include "main.h"

const int tile_size = 32;
const int ponyphases = 4;
const int deltaphase = 8;

SDL_Rect right[4];
SDL_Rect down[4];
SDL_Rect left[4];
SDL_Rect up[4];

SDL_Surface *pony;
static SDL_Surface *background;
SDL_Surface *tile;
SDL_Surface *ground;
SDL_Surface *target;
SDL_Surface *box;
SDL_Surface *counter;

static  SDL_Color black = {0,0,0};
static TTF_Font *font;

typedef struct {
    int x,y;
    int dirx, diry;
    int phase;
    int steps;
} charstate;

void fontinit(){
    /*Betûtipus betöltése*/
    TTF_Init();
    font = TTF_OpenFont("LSANSD.ttf", 20);
    if (!font) {
        fprintf(stderr, "Nem sikerult betölteni a betutipust! %s\n", TTF_GetError());
        exit(2);
    }
}

void loadimages() {
    /*Szükséges képek betöltése*/
    pony = IMG_Load("pic/pony.png");
    background = IMG_Load("pic/bg.png");
    tile = IMG_Load("pic/tile.png");
    ground = IMG_Load("pic/floor.png");
    target = IMG_Load("pic/target.png");
    box = IMG_Load("pic/box.png");

    if (pony == NULL || tile == NULL || ground == NULL || target == NULL || background == NULL || box == NULL){
        fprintf(stderr, "Nem sikerült betölteni a játékhoz a képeket!\n");
        exit(3);
    }
}

void loadlevel(koor *charpos, lab *lab, int level){
    int i;
    FILE *f;
    char filepath[20];
    koor bp;

    sprintf(filepath, "levels/level%d.txt", level+1);

    /*Fájl megnyitása*/
    f = fopen(filepath,"rt");
    if (f == NULL){
        fprintf(stderr, "Nem sikerült megnyitni a fájlt!");
        exit(3);
    }
    /*Beolvasás: dobozok száma*/
    fscanf(f, "%d", &lab->numofbox);

    /*A dobozok pozícióinak tárolásához szükséges tömb lefoglalása*/
    lab->boxpos = (koor *) malloc(lab->numofbox*sizeof(koor)); //tömb lefoglalása
    if (lab->boxpos == NULL) {
        printf("Nem sikerült memóriát foglalni!\n");
        exit(2);
    }
    /*Beolvasás: dobozok pozíciója*/
    for (i = 0; i < lab->numofbox; i++){
        fscanf(f, "%d", &bp.x);
        fscanf(f, "%d", &bp.y);
        lab->boxpos[i] = bp;
    }

    /*Beolvasás: karakter pozíciója*/
    fscanf(f, "%d", &charpos->x);
    fscanf(f, "%d", &charpos->y);

    /*Beolvasás: labirintus mérete*/
    fscanf(f, "%d", &lab->level_w);
    fscanf(f, "%d", &lab->level_h);

    /*A labirintus tárolásához szükséges tömb lefoglalása*/
    lab->map = (char *)malloc(lab->level_w*lab->level_h*sizeof(char));//lefoglalás
    if (lab->map == NULL) {
        printf("Nem sikerült memóriát foglalni!\n");
        exit(2);
    }

    /*Beolvasás: labirintus*/
    char pos;
    i = 0;
    while (i < lab->level_w*lab->level_h){
        fscanf(f, "%c", &pos);
        if (pos != '\n'){
            lab->map[i] = pos;
            i++;
        }
    }
    fclose(f);
}

void loadponystates (){
    int i;
    //Jobbra
    for (i=0; i<4; i++) {
        right[i].x = i*32;
        right[i].y = 0*tile_size;
        right[i].w = right[i].h = tile_size;
    }

    //Lefelé
    for(i=0;i<4;i++){
        down[i].x = i*32;
        down[i].y = 1*tile_size;
        down[i].w = down[i].h = tile_size;
    }
    //Balra
    for(i=0;i<4;i++){
        left[i].x = i*32;
        left[i].y = 2*tile_size;
        left[i].w = left[i].h = tile_size;
    }
    //Felfelé
    for (i=0;i<4;i++){
        up[i].x = i*32;
        up[i].y = 3*tile_size;
        up[i].w = up[i].h = tile_size;
    }

}

void drawcounter(SDL_Surface *screen, int steps){
    char counter_s[10];
    sprintf(counter_s, "%d", steps);
    counter = TTF_RenderUTF8_Blended(font, counter_s, black);
    SDL_Rect dest = {8,0,0,0};
    SDL_BlitSurface(counter, NULL, screen, &dest);
    SDL_FreeSurface(counter);
}

void drawpony (SDL_Surface *screen, lab *lab, charstate *ponystate){
    int i,x,y;
    x = (480 - lab->level_w*tile_size)/2 + ponystate->x*tile_size + deltaphase * ponystate->dirx * ponystate->phase;
    y = (480 - lab->level_h*tile_size)/2 + ponystate->y*tile_size + deltaphase * ponystate->diry * ponystate->phase;
    SDL_Rect dest = {x, y, 0,0};
    SDL_Rect *rect;
    switch (ponystate->dirx) {
        case -1: rect = left; break;
        case 1: rect = right; break;
        default: switch (ponystate->diry) {
            case -1: rect = up; break;
            default: rect = down; break;
        }
    }
    SDL_BlitSurface(pony, &rect[ponystate->phase], screen, &dest);
}

void drawbox (SDL_Surface *screen, lab *lab, koor boxpos, charstate *ponystate, int push){
    int x,y;
    //fprintf(stderr, "boxpos = %d", boxpos);
    if(push == 0){
        x = (480 - lab->level_w*tile_size)/2 + boxpos.x*tile_size;
        y = (480 - lab->level_h*tile_size)/2 + boxpos.y*tile_size;
        SDL_Rect dest = {x,y,0,0};
        SDL_BlitSurface(box, NULL, screen, &dest);
    }
    else {
        x = (480 - lab->level_w*tile_size)/2 + boxpos.x*tile_size + deltaphase * ponystate->dirx * ponystate->phase;
        y = (480 - lab->level_h*tile_size)/2 + boxpos.y*tile_size + deltaphase * ponystate->diry * ponystate->phase;
        SDL_Rect dest = {x,y,0,0};
        SDL_BlitSurface(box, NULL, screen, &dest);
    }
}

void drawmap(SDL_Surface *screen, lab *lab, charstate *ponystate, int push, int which){
    int x,y,i;
   // SDL_Rect bg = {0,0,0,0};
    SDL_BlitSurface(background, NULL, screen, NULL);

    //todo: 2 ciklus
    for (i = 0; i < lab->level_w * lab->level_h; i++){
        x = (480 - lab->level_w*tile_size)/2 + i%lab->level_w*tile_size;
        y = (480 - lab->level_h*tile_size)/2 + i/lab->level_w*tile_size;
        SDL_Rect dest = {x,y,0,0};

        if (lab->map[i] == '#')
            SDL_BlitSurface(tile, NULL, screen, &dest);
        if (lab->map[i] == '.')
            SDL_BlitSurface(floor, NULL, screen, &dest);
        if(lab->map[i] == 'T')
            SDL_BlitSurface(target, NULL, screen, &dest);
    }

    drawcounter(screen, ponystate->steps);
    drawpony(screen, lab, ponystate);
    for(i = 0; i < lab->numofbox; i++){
        drawbox(screen, lab, lab->boxpos[i], ponystate, push && which == i);
    }
    SDL_Flip(screen);
}

int move(charstate *ponystate, int boxstate[], int dirx, int diry, SDL_Surface *screen, lab *lab){
    int i, j;
    ponystate->dirx = dirx;
    ponystate->diry = diry;
    int x      = ponystate->x + dirx + (ponystate->y+diry)*lab->level_w;
    int xplus1 = ponystate->x + 2*dirx + (ponystate->y+2*diry)*lab->level_w;

    //Doboz
    int push = 0;
    int hit = 0;
    int which;
    int goal = 0;

    //Ütközés keresése
    for (i = 0; i < lab->numofbox; i++){
    /*Ha doboz+fal van elõtte*/
        if(x == boxstate[i] && lab->map[xplus1] == '#')
            hit++;
        /*Ha kettõ doboz van elõtte*/
        for(j = 0; j < lab->numofbox; j++){
            if(x == boxstate[i] && xplus1 == boxstate[j])
                hit++;
        }
        if(x == boxstate[i] && !hit){
            push++;
            which = i;
        }
    }



    if(lab->map[x] != '#' && !hit){
        ponystate->steps++;
        for (i = 0; i < ponyphases; i++){
            ponystate->phase = i;
            drawmap(screen, lab, ponystate, push, which);
            SDL_Delay(60);
        }
        if(push){
            lab->boxpos[which].x += dirx;
            lab->boxpos[which].y += diry;
            boxstate[which] = lab->boxpos[which].x + lab->boxpos[which].y*lab->level_w;
        }
        ponystate->phase = 0;
        ponystate->x += dirx;
        ponystate->y += diry;
    }
    drawmap(screen, lab, ponystate, push, which);
    if(push){
        for(j = 0; j < lab->numofbox; j++){
            if(lab->map[boxstate[j]] == 'T')
                goal++;
        }
        if(goal == lab->numofbox){
            return 1;
        }
    }
    return 0;
}

int game_event_loop (SDL_Surface *screen, koor *charpos, lab *lab, int *game, int *result){
    const int middle = (480 - lab->level_w*tile_size)/2;
    SDL_Event event;
    int i;
    int win = 0;
    int loop = 1;
    charstate ponystate = {charpos->x, charpos->y, 0, 1, 0, 0};
    int boxstate[lab->numofbox];
    for(i = 0; i < lab->numofbox; i++){
        boxstate[i] = lab->boxpos[i].x + lab->boxpos[i].y*lab->level_w;
    }
    drawmap(screen, lab, &ponystate, 0, 0);
    while (loop) {
        if (SDL_PollEvent(&event)) {
            switch (event.type){
                case SDL_KEYDOWN: {
                    switch (event.key.keysym.sym){
                        case SDLK_q: {
                            *game = 0;
                            loop = 0;
                            break;
                        }
                        case SDLK_r:{
                            loop = 0;
                            break;
                        }
                        case SDLK_RIGHT: {
                            win = move(&ponystate, boxstate, 1, 0, screen, lab);
                            break;
                        }
                        case SDLK_DOWN: {
                            win = move(&ponystate, boxstate, 0, 1, screen, lab);
                            break;
                        }
                        case SDLK_LEFT: {
                            win = move(&ponystate, boxstate, -1, 0, screen, lab);
                            break;
                        }
                        case SDLK_UP: {
                            win = move(&ponystate, boxstate, 0, -1, screen, lab);
                            break;
                        }
                        default: break;
                    }
                    if(win){
                        loop = 0;
                        *result = ponystate.steps;
                    }
                }
                break;
                default: break;
            }
        }
    }
    return win;
}

void freegame(){
    SDL_FreeSurface(pony);
    SDL_FreeSurface(background);
    SDL_FreeSurface(tile);
    SDL_FreeSurface(ground);
    SDL_FreeSurface(target);
    SDL_FreeSurface(box);
}
